{"version":3,"file":"worker-script.js","sources":["../../../src/formats/bru/utils/oauth2-additional-params.ts","../../../src/formats/bru/index.ts","../../../src/workers/worker-script.ts"],"sourcesContent":["type T_Oauth2ParameterType = 'authorization' | 'token' | 'refresh';\ntype T_Oauth2ParameterSendInType = 'headers' | 'queryparams' | 'body';\n\nexport interface T_OAuth2AdditionalParam {\n  name: string;\n  value: string;\n  enabled: boolean;\n  sendIn: T_Oauth2ParameterSendInType\n}\n\nexport interface T_OAuth2AdditionalParameters {\n  authorization?: T_OAuth2AdditionalParam[];\n  token?: T_OAuth2AdditionalParam[];\n  refresh?: T_OAuth2AdditionalParam[];\n}\n\nexport interface T_Oauth2Auth {\n  grantType: string;\n  additionalParameters?: T_OAuth2AdditionalParameters;\n}\n\nexport interface T_BruJson {\n  auth: {\n    oauth2: T_Oauth2Auth;\n  };\n  oauth2_additional_parameters_auth_req_headers?: any[];\n  oauth2_additional_parameters_auth_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_headers?: any[];\n  oauth2_additional_parameters_access_token_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_bodyvalues?: any[];\n  oauth2_additional_parameters_refresh_token_req_headers?: any[];\n  oauth2_additional_parameters_refresh_token_req_queryparams?: any[];\n  oauth2_additional_parameters_refresh_token_req_bodyvalues?: any[];\n}\n\ninterface T_Oauth2ParameterMapping {\n  type: T_Oauth2ParameterType;\n  sendIn: T_Oauth2ParameterSendInType;\n  source: keyof T_BruJson;\n}\n\nconst PARAMETER_MAPPINGS: T_Oauth2ParameterMapping[] = [\n  // Authorization parameters (only for authorization_code grant type)\n  { type: 'authorization', sendIn: 'headers', source: 'oauth2_additional_parameters_auth_req_headers' },\n  { type: 'authorization', sendIn: 'queryparams', source: 'oauth2_additional_parameters_auth_req_queryparams' },\n  \n  // Token parameters (for all grant types)\n  { type: 'token', sendIn: 'headers', source: 'oauth2_additional_parameters_access_token_req_headers' },\n  { type: 'token', sendIn: 'queryparams', source: 'oauth2_additional_parameters_access_token_req_queryparams' },\n  { type: 'token', sendIn: 'body', source: 'oauth2_additional_parameters_access_token_req_bodyvalues' },\n  \n  // Refresh parameters (for grant types that support refresh)\n  { type: 'refresh', sendIn: 'headers', source: 'oauth2_additional_parameters_refresh_token_req_headers' },\n  { type: 'refresh', sendIn: 'queryparams', source: 'oauth2_additional_parameters_refresh_token_req_queryparams' },\n  { type: 'refresh', sendIn: 'body', source: 'oauth2_additional_parameters_refresh_token_req_bodyvalues' },\n];\n\n/**\n * Maps source parameters to T_OAuth2AdditionalParam format\n */\nconst mapParametersFromSource = (sourceParams: any[], sendIn: T_Oauth2ParameterSendInType): T_OAuth2AdditionalParam[] => {\n  if (!sourceParams?.length) {\n    return [];\n  }\n  \n  return sourceParams.map(param => ({\n    ...param,\n    sendIn\n  }));\n};\n\n/**\n * Checks if a parameter type should be included based on grant type\n */\nconst shouldIncludeParameterType = (type: T_Oauth2ParameterType, grantType: string): boolean => {\n  // Authorization parameters are only valid for authorization_code grant type\n  if (type === 'authorization') {\n    return grantType === 'authorization_code' || grantType === 'implicit';\n  }\n\n  if (type === 'token' || type === 'refresh') {\n    return grantType !== 'implicit';\n  }\n  \n  // Token and refresh parameters are valid for all grant types\n  return true;\n};\n\n/**\n * Collects all parameters for a specific type (authorization, token, or refresh)\n */\nconst collectParametersForType = (\n  json: T_BruJson, \n  type: T_Oauth2ParameterType, \n  grantType: string\n): T_OAuth2AdditionalParam[] => {\n  if (!shouldIncludeParameterType(type, grantType)) {\n    return [];\n  }\n\n  const relevantMappings = PARAMETER_MAPPINGS.filter(mapping => mapping.type === type);\n  const allParams: T_OAuth2AdditionalParam[] = [];\n\n  for (const mapping of relevantMappings) {\n    const sourceParams = json[mapping.source] as any[];\n    const mappedParams = mapParametersFromSource(sourceParams, mapping.sendIn);\n    allParams.push(...mappedParams);\n  }\n\n  return allParams;\n};\n\n/**\n * This function extracts OAuth2 additional parameters from various sources in the bru json data and organizes\n * them into a structured format based on their usage context (authorization, token, refresh).\n * \n * @param json - json object containing OAuth2 configuration and additional parameters\n * @returns OAuth2 additional parameters\n */\nexport const getOauth2AdditionalParameters = (json: T_BruJson): T_OAuth2AdditionalParameters  => {\n  const grantType = json.auth.oauth2.grantType;\n  const additionalParameters: T_OAuth2AdditionalParameters = {};\n\n  try {\n    // Collect parameters for each type\n    const parameterTypes: T_Oauth2ParameterType[] = ['authorization', 'token', 'refresh'];\n    \n    for (const type of parameterTypes) {\n      const params = collectParametersForType(json, type, grantType);\n      if (params.length > 0) {\n        additionalParameters[type] = params;\n      }\n    }\n  }\n  catch(error) {\n    console.error(error);\n    console.error(\"Error while getting the oauth2 additional parameters!\");\n  }\n  \n  return additionalParameters;\n};","import * as _ from 'lodash';\nimport {\n  bruToJsonV2,\n  jsonToBruV2,\n  bruToEnvJsonV2,\n  envJsonToBruV2,\n  collectionBruToJson as _collectionBruToJson,\n  jsonToCollectionBru as _jsonToCollectionBru\n} from '@usebruno/lang';\nimport { getOauth2AdditionalParameters } from './utils/oauth2-additional-params';\n\nexport const bruRequestToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : bruToJsonV2(data);\n\n    let requestType = _.get(json, 'meta.type');\n    switch (requestType) {\n      case 'http':\n        requestType = 'http-request';\n        break;\n      case 'graphql':\n        requestType = 'graphql-request';\n        break;\n      case 'grpc':\n        requestType = 'grpc-request';\n        break;\n      default:\n        requestType = 'http-request';\n    }\n\n    const sequence = _.get(json, 'meta.seq');\n    const transformedJson = {\n      type: requestType,\n      name: _.get(json, 'meta.name'),\n      seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n      settings: _.get(json, 'settings', {}),\n      tags: _.get(json, 'meta.tags', []),\n      request: {\n        // Preserving special characters in custom methods. Using _.upperCase strips special characters.\n        method:\n          requestType === 'grpc-request' ? _.get(json, 'grpc.method', '') : String(_.get(json, 'http.method') ?? '').toUpperCase(),\n        url: _.get(json, requestType === 'grpc-request' ? 'grpc.url' : 'http.url'),\n        headers: requestType === 'grpc-request' ? _.get(json, 'metadata', []) : _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        body: _.get(json, 'body', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        assertions: _.get(json, 'assertions', []),\n        tests: _.get(json, 'tests', ''),\n        docs: _.get(json, 'docs', '')\n      }\n    };\n\n    // Add request type specific fields\n    if (requestType === 'grpc-request') {\n      const selectedMethodType = _.get(json, 'grpc.methodType');\n      selectedMethodType && ((transformedJson.request as any).methodType = selectedMethodType);\n      const protoPath = _.get(json, 'grpc.protoPath');\n      protoPath && ((transformedJson.request as any).protoPath = protoPath);\n      transformedJson.request.auth.mode = _.get(json, 'grpc.auth', 'none');\n      transformedJson.request.body = _.get(json, 'body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    } else {\n      // For HTTP and GraphQL\n      (transformedJson.request as any).params = _.get(json, 'params', []);\n      transformedJson.request.auth.mode = _.get(json, 'http.auth', 'none');\n      transformedJson.request.body.mode = _.get(json, 'http.body', 'none');\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters || {}).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const jsonRequestToBru = (json: any): string => {\n  try {\n    let type = _.get(json, 'type');\n    switch (type) {\n      case 'http-request':\n        type = 'http';\n        break;\n      case 'graphql-request':\n        type = 'graphql';\n        break;\n      case 'grpc-request':\n        type = 'grpc';\n        break;\n      default:\n        type = 'http';\n    }\n\n    const sequence = _.get(json, 'seq');\n\n    // Start with the common meta section\n    const bruJson = {\n      meta: {\n        name: _.get(json, 'name'),\n        type: type,\n        seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n        tags: _.get(json, 'tags', [])\n      }\n    } as any;\n\n    // For HTTP and GraphQL requests, maintain the current structure\n    if (type === 'http' || type === 'graphql') {\n      bruJson.http = {\n        // Preserve special characters in custom request methods. Avoid _.lowerCase which strips symbols.\n        method: String(_.get(json, 'request.method') ?? '').toLowerCase(),\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'none')\n      };\n      bruJson.params = _.get(json, 'request.params', []);\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'json',\n        json: '{}'\n      });\n    } // For gRPC, add gRPC-specific structure but maintain field names\n    else if (type === 'grpc') {\n      bruJson.grpc = {\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'grpc')\n      };\n      // Only add method if it exists\n      const method = _.get(json, 'request.method');\n      const methodType = _.get(json, 'request.methodType');\n      const protoPath = _.get(json, 'request.protoPath');\n      if (method) bruJson.grpc.method = method;\n      if (methodType) bruJson.grpc.methodType = methodType;\n      if (protoPath) bruJson.grpc.protoPath = protoPath;\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'request.body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    }\n\n    // Common fields for all request types\n    if (type === 'grpc') {\n      bruJson.metadata = _.get(json, 'request.headers', []); // Use metadata for gRPC\n    } else {\n      bruJson.headers = _.get(json, 'request.headers', []); // Use headers for HTTP/GraphQL\n    }\n    bruJson.auth = _.get(json, 'request.auth', {});\n    bruJson.script = _.get(json, 'request.script', {});\n    bruJson.vars = {\n      req: _.get(json, 'request.vars.req', []),\n      res: _.get(json, 'request.vars.res', [])\n    };\n    // should we add assertions and tests for grpc requests?\n    bruJson.assertions = _.get(json, 'request.assertions', []);\n    bruJson.tests = _.get(json, 'request.tests', '');\n    bruJson.settings = _.get(json, 'settings', {});\n    bruJson.docs = _.get(json, 'request.docs', '');\n\n    const bru = jsonToBruV2(bruJson);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruCollectionToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : _collectionBruToJson(data);\n\n    const transformedJson: any = {\n      request: {\n        headers: _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        tests: _.get(json, 'tests', '')\n      },\n      settings: _.get(json, 'settings', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json.meta) {\n      transformedJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        transformedJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonCollectionToBru = (json: any, isFolder?: boolean): string => {\n  try {\n    const collectionBruJson: any = {\n      headers: _.get(json, 'request.headers', []),\n      script: {\n        req: _.get(json, 'request.script.req', ''),\n        res: _.get(json, 'request.script.res', '')\n      },\n      vars: {\n        req: _.get(json, 'request.vars.req', []),\n        res: _.get(json, 'request.vars.res', [])\n      },\n      tests: _.get(json, 'request.tests', ''),\n      auth: _.get(json, 'request.auth', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json?.meta) {\n      collectionBruJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        collectionBruJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    if (!isFolder) {\n      collectionBruJson.auth = _.get(json, 'request.auth', {});\n    }\n\n    return _jsonToCollectionBru(collectionBruJson);\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruEnvironmentToJson = (bru: string): any => {\n  try {\n    const json = bruToEnvJsonV2(bru);\n\n    // the app env format requires each variable to have a type\n    // this need to be evaluated and safely removed\n    // i don't see it being used in schema validation\n    if (json && json.variables && json.variables.length) {\n      _.each(json.variables, (v: any) => (v.type = 'text'));\n    }\n\n    return json;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonEnvironmentToBru = (json: any): string => {\n  try {\n    const bru = envJsonToBruV2(json);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n","import { parentPort } from 'node:worker_threads';\nimport { bruRequestToJson, jsonRequestToBru } from '../formats/bru';\n\ninterface WorkerMessage {\n  taskType: 'parse' | 'stringify';\n  data: any;\n}\n\nparentPort?.on('message', async (message: WorkerMessage) => {\n  try {\n    const { taskType, data } = message;\n    let result: any;\n\n    if (taskType === 'parse') {\n      result = bruRequestToJson(data);\n    } else if (taskType === 'stringify') {\n      result = jsonRequestToBru(data);\n    } else {\n      throw new Error(`Unknown task type: ${taskType}`);\n    }\n\n    parentPort?.postMessage(result);\n  } catch (error: any) {\n    console.error('Worker error:', error);\n    parentPort?.postMessage({ error: error?.message });\n  }\n});"],"names":["PARAMETER_MAPPINGS","type","sendIn","source","mapParametersFromSource","sourceParams","length","map","param","collectParametersForType","json","grantType","shouldIncludeParameterType","relevantMappings","filter","mapping","allParams","mappedParams","push","bruRequestToJson","data","parsed","bruToJsonV2","requestType","_","get","sequence","transformedJson","name","seq","isNaN","Number","settings","tags","request","method","String","toUpperCase","url","headers","auth","body","script","vars","assertions","tests","docs","selectedMethodType","methodType","protoPath","mode","grpc","content","params","hasOauth2GrantType","oauth2","additionalParameters","parameterTypes","error","console","getOauth2AdditionalParameters","Object","keys","parentPort","on","async","message","taskType","result","Error","bruJson","meta","http","toLowerCase","metadata","req","res","jsonToBruV2","jsonRequestToBru","postMessage"],"mappings":"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"}