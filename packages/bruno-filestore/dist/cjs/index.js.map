{"version":3,"file":"index.js","sources":["../../src/formats/bru/utils/oauth2-additional-params.ts","../../src/formats/bru/index.ts","../../src/workers/WorkerQueue/index.ts","../../src/workers/index.ts","../../src/index.ts","../../src/formats/bru/utils/request-parse-and-redact-body-data.ts"],"sourcesContent":["type T_Oauth2ParameterType = 'authorization' | 'token' | 'refresh';\ntype T_Oauth2ParameterSendInType = 'headers' | 'queryparams' | 'body';\n\nexport interface T_OAuth2AdditionalParam {\n  name: string;\n  value: string;\n  enabled: boolean;\n  sendIn: T_Oauth2ParameterSendInType\n}\n\nexport interface T_OAuth2AdditionalParameters {\n  authorization?: T_OAuth2AdditionalParam[];\n  token?: T_OAuth2AdditionalParam[];\n  refresh?: T_OAuth2AdditionalParam[];\n}\n\nexport interface T_Oauth2Auth {\n  grantType: string;\n  additionalParameters?: T_OAuth2AdditionalParameters;\n}\n\nexport interface T_BruJson {\n  auth: {\n    oauth2: T_Oauth2Auth;\n  };\n  oauth2_additional_parameters_auth_req_headers?: any[];\n  oauth2_additional_parameters_auth_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_headers?: any[];\n  oauth2_additional_parameters_access_token_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_bodyvalues?: any[];\n  oauth2_additional_parameters_refresh_token_req_headers?: any[];\n  oauth2_additional_parameters_refresh_token_req_queryparams?: any[];\n  oauth2_additional_parameters_refresh_token_req_bodyvalues?: any[];\n}\n\ninterface T_Oauth2ParameterMapping {\n  type: T_Oauth2ParameterType;\n  sendIn: T_Oauth2ParameterSendInType;\n  source: keyof T_BruJson;\n}\n\nconst PARAMETER_MAPPINGS: T_Oauth2ParameterMapping[] = [\n  // Authorization parameters (only for authorization_code grant type)\n  { type: 'authorization', sendIn: 'headers', source: 'oauth2_additional_parameters_auth_req_headers' },\n  { type: 'authorization', sendIn: 'queryparams', source: 'oauth2_additional_parameters_auth_req_queryparams' },\n  \n  // Token parameters (for all grant types)\n  { type: 'token', sendIn: 'headers', source: 'oauth2_additional_parameters_access_token_req_headers' },\n  { type: 'token', sendIn: 'queryparams', source: 'oauth2_additional_parameters_access_token_req_queryparams' },\n  { type: 'token', sendIn: 'body', source: 'oauth2_additional_parameters_access_token_req_bodyvalues' },\n  \n  // Refresh parameters (for grant types that support refresh)\n  { type: 'refresh', sendIn: 'headers', source: 'oauth2_additional_parameters_refresh_token_req_headers' },\n  { type: 'refresh', sendIn: 'queryparams', source: 'oauth2_additional_parameters_refresh_token_req_queryparams' },\n  { type: 'refresh', sendIn: 'body', source: 'oauth2_additional_parameters_refresh_token_req_bodyvalues' },\n];\n\n/**\n * Maps source parameters to T_OAuth2AdditionalParam format\n */\nconst mapParametersFromSource = (sourceParams: any[], sendIn: T_Oauth2ParameterSendInType): T_OAuth2AdditionalParam[] => {\n  if (!sourceParams?.length) {\n    return [];\n  }\n  \n  return sourceParams.map(param => ({\n    ...param,\n    sendIn\n  }));\n};\n\n/**\n * Checks if a parameter type should be included based on grant type\n */\nconst shouldIncludeParameterType = (type: T_Oauth2ParameterType, grantType: string): boolean => {\n  // Authorization parameters are only valid for authorization_code grant type\n  if (type === 'authorization') {\n    return grantType === 'authorization_code' || grantType === 'implicit';\n  }\n\n  if (type === 'token' || type === 'refresh') {\n    return grantType !== 'implicit';\n  }\n  \n  // Token and refresh parameters are valid for all grant types\n  return true;\n};\n\n/**\n * Collects all parameters for a specific type (authorization, token, or refresh)\n */\nconst collectParametersForType = (\n  json: T_BruJson, \n  type: T_Oauth2ParameterType, \n  grantType: string\n): T_OAuth2AdditionalParam[] => {\n  if (!shouldIncludeParameterType(type, grantType)) {\n    return [];\n  }\n\n  const relevantMappings = PARAMETER_MAPPINGS.filter(mapping => mapping.type === type);\n  const allParams: T_OAuth2AdditionalParam[] = [];\n\n  for (const mapping of relevantMappings) {\n    const sourceParams = json[mapping.source] as any[];\n    const mappedParams = mapParametersFromSource(sourceParams, mapping.sendIn);\n    allParams.push(...mappedParams);\n  }\n\n  return allParams;\n};\n\n/**\n * This function extracts OAuth2 additional parameters from various sources in the bru json data and organizes\n * them into a structured format based on their usage context (authorization, token, refresh).\n * \n * @param json - json object containing OAuth2 configuration and additional parameters\n * @returns OAuth2 additional parameters\n */\nexport const getOauth2AdditionalParameters = (json: T_BruJson): T_OAuth2AdditionalParameters  => {\n  const grantType = json.auth.oauth2.grantType;\n  const additionalParameters: T_OAuth2AdditionalParameters = {};\n\n  try {\n    // Collect parameters for each type\n    const parameterTypes: T_Oauth2ParameterType[] = ['authorization', 'token', 'refresh'];\n    \n    for (const type of parameterTypes) {\n      const params = collectParametersForType(json, type, grantType);\n      if (params.length > 0) {\n        additionalParameters[type] = params;\n      }\n    }\n  }\n  catch(error) {\n    console.error(error);\n    console.error(\"Error while getting the oauth2 additional parameters!\");\n  }\n  \n  return additionalParameters;\n};","import * as _ from 'lodash';\nimport {\n  bruToJsonV2,\n  jsonToBruV2,\n  bruToEnvJsonV2,\n  envJsonToBruV2,\n  collectionBruToJson as _collectionBruToJson,\n  jsonToCollectionBru as _jsonToCollectionBru\n} from '@usebruno/lang';\nimport { getOauth2AdditionalParameters } from './utils/oauth2-additional-params';\n\nexport const bruRequestToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : bruToJsonV2(data);\n\n    let requestType = _.get(json, 'meta.type');\n    switch (requestType) {\n      case 'http':\n        requestType = 'http-request';\n        break;\n      case 'graphql':\n        requestType = 'graphql-request';\n        break;\n      case 'grpc':\n        requestType = 'grpc-request';\n        break;\n      default:\n        requestType = 'http-request';\n    }\n\n    const sequence = _.get(json, 'meta.seq');\n    const transformedJson = {\n      type: requestType,\n      name: _.get(json, 'meta.name'),\n      seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n      settings: _.get(json, 'settings', {}),\n      tags: _.get(json, 'meta.tags', []),\n      request: {\n        // Preserving special characters in custom methods. Using _.upperCase strips special characters.\n        method:\n          requestType === 'grpc-request' ? _.get(json, 'grpc.method', '') : String(_.get(json, 'http.method') ?? '').toUpperCase(),\n        url: _.get(json, requestType === 'grpc-request' ? 'grpc.url' : 'http.url'),\n        headers: requestType === 'grpc-request' ? _.get(json, 'metadata', []) : _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        body: _.get(json, 'body', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        assertions: _.get(json, 'assertions', []),\n        tests: _.get(json, 'tests', ''),\n        docs: _.get(json, 'docs', '')\n      }\n    };\n\n    // Add request type specific fields\n    if (requestType === 'grpc-request') {\n      const selectedMethodType = _.get(json, 'grpc.methodType');\n      selectedMethodType && ((transformedJson.request as any).methodType = selectedMethodType);\n      const protoPath = _.get(json, 'grpc.protoPath');\n      protoPath && ((transformedJson.request as any).protoPath = protoPath);\n      transformedJson.request.auth.mode = _.get(json, 'grpc.auth', 'none');\n      transformedJson.request.body = _.get(json, 'body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    } else {\n      // For HTTP and GraphQL\n      (transformedJson.request as any).params = _.get(json, 'params', []);\n      transformedJson.request.auth.mode = _.get(json, 'http.auth', 'none');\n      transformedJson.request.body.mode = _.get(json, 'http.body', 'none');\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters || {}).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const jsonRequestToBru = (json: any): string => {\n  try {\n    let type = _.get(json, 'type');\n    switch (type) {\n      case 'http-request':\n        type = 'http';\n        break;\n      case 'graphql-request':\n        type = 'graphql';\n        break;\n      case 'grpc-request':\n        type = 'grpc';\n        break;\n      default:\n        type = 'http';\n    }\n\n    const sequence = _.get(json, 'seq');\n\n    // Start with the common meta section\n    const bruJson = {\n      meta: {\n        name: _.get(json, 'name'),\n        type: type,\n        seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n        tags: _.get(json, 'tags', [])\n      }\n    } as any;\n\n    // For HTTP and GraphQL requests, maintain the current structure\n    if (type === 'http' || type === 'graphql') {\n      bruJson.http = {\n        // Preserve special characters in custom request methods. Avoid _.lowerCase which strips symbols.\n        method: String(_.get(json, 'request.method') ?? '').toLowerCase(),\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'none')\n      };\n      bruJson.params = _.get(json, 'request.params', []);\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'json',\n        json: '{}'\n      });\n    } // For gRPC, add gRPC-specific structure but maintain field names\n    else if (type === 'grpc') {\n      bruJson.grpc = {\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'grpc')\n      };\n      // Only add method if it exists\n      const method = _.get(json, 'request.method');\n      const methodType = _.get(json, 'request.methodType');\n      const protoPath = _.get(json, 'request.protoPath');\n      if (method) bruJson.grpc.method = method;\n      if (methodType) bruJson.grpc.methodType = methodType;\n      if (protoPath) bruJson.grpc.protoPath = protoPath;\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'request.body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    }\n\n    // Common fields for all request types\n    if (type === 'grpc') {\n      bruJson.metadata = _.get(json, 'request.headers', []); // Use metadata for gRPC\n    } else {\n      bruJson.headers = _.get(json, 'request.headers', []); // Use headers for HTTP/GraphQL\n    }\n    bruJson.auth = _.get(json, 'request.auth', {});\n    bruJson.script = _.get(json, 'request.script', {});\n    bruJson.vars = {\n      req: _.get(json, 'request.vars.req', []),\n      res: _.get(json, 'request.vars.res', [])\n    };\n    // should we add assertions and tests for grpc requests?\n    bruJson.assertions = _.get(json, 'request.assertions', []);\n    bruJson.tests = _.get(json, 'request.tests', '');\n    bruJson.settings = _.get(json, 'settings', {});\n    bruJson.docs = _.get(json, 'request.docs', '');\n\n    const bru = jsonToBruV2(bruJson);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruCollectionToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : _collectionBruToJson(data);\n\n    const transformedJson: any = {\n      request: {\n        headers: _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        tests: _.get(json, 'tests', '')\n      },\n      settings: _.get(json, 'settings', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json.meta) {\n      transformedJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        transformedJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonCollectionToBru = (json: any, isFolder?: boolean): string => {\n  try {\n    const collectionBruJson: any = {\n      headers: _.get(json, 'request.headers', []),\n      script: {\n        req: _.get(json, 'request.script.req', ''),\n        res: _.get(json, 'request.script.res', '')\n      },\n      vars: {\n        req: _.get(json, 'request.vars.req', []),\n        res: _.get(json, 'request.vars.res', [])\n      },\n      tests: _.get(json, 'request.tests', ''),\n      auth: _.get(json, 'request.auth', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json?.meta) {\n      collectionBruJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        collectionBruJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    if (!isFolder) {\n      collectionBruJson.auth = _.get(json, 'request.auth', {});\n    }\n\n    return _jsonToCollectionBru(collectionBruJson);\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruEnvironmentToJson = (bru: string): any => {\n  try {\n    const json = bruToEnvJsonV2(bru);\n\n    // the app env format requires each variable to have a type\n    // this need to be evaluated and safely removed\n    // i don't see it being used in schema validation\n    if (json && json.variables && json.variables.length) {\n      _.each(json.variables, (v: any) => (v.type = 'text'));\n    }\n\n    return json;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonEnvironmentToBru = (json: any): string => {\n  try {\n    const bru = envJsonToBruV2(json);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n","import { Worker } from 'node:worker_threads';\n\ninterface QueuedTask {\n  priority: number;\n  scriptPath: string;\n  data: any;\n  taskType: 'parse' | 'stringify';\n  resolve?: (value: any) => void;\n  reject?: (reason?: any) => void;\n}\n\nclass WorkerQueue {\n  private queue: QueuedTask[];\n  private isProcessing: boolean;\n  private workers: Record<string, Worker>;\n\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n    this.workers = {};\n  }\n\n  async getWorkerForScriptPath(scriptPath: string) {\n    if (!this.workers) this.workers = {}; \n    let worker = this.workers[scriptPath];\n    if (!worker || worker.threadId === -1) {\n      this.workers[scriptPath] = worker = new Worker(scriptPath);\n    }\n    return worker;\n  }\n  \n  async enqueue(task: QueuedTask) {\n    const { priority, scriptPath, data, taskType } = task;\n\n    return new Promise((resolve, reject) => {\n      this.queue.push({ priority, scriptPath, data, taskType, resolve, reject });\n      this.queue?.sort((taskX, taskY) => taskX?.priority - taskY?.priority);\n      this.processQueue();\n    });\n  }\n\n  async processQueue() {\n    if (this.isProcessing || this.queue.length === 0){\n      return;\n    } \n\n    this.isProcessing = true;\n    const { scriptPath, data, taskType, resolve, reject } = this.queue.shift() as QueuedTask;\n\n    try {\n      const result = await this.runWorker({ scriptPath, data, taskType });\n      resolve?.(result);\n    } catch (error) {\n      reject?.(error);\n    } finally {\n      this.isProcessing = false;\n      this.processQueue();\n    }\n  }\n\n  async runWorker({ scriptPath, data, taskType }: { scriptPath: string; data: any; taskType: 'parse' | 'stringify' }) {\n    return new Promise(async (resolve, reject) => {\n      let worker = await this.getWorkerForScriptPath(scriptPath);\n      \n      const messageHandler = (data: any) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        \n        if (data?.error) {\n          reject(new Error(data?.error));\n        } else {\n          resolve(data);\n        }\n      };\n\n      const errorHandler = (error: Error) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        reject(error);\n      };\n\n      const exitHandler = (code: number) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        // Remove dead worker from cache\n        delete this.workers[scriptPath];\n        reject(new Error(`Worker stopped with exit code ${code}`));\n      };\n      \n      worker.on('message', messageHandler);\n      worker.on('error', errorHandler);\n      worker.on('exit', exitHandler);\n\n      worker.postMessage({ taskType, data });\n    });\n  }\n\n  async cleanup() {\n    const promises = Object.values(this.workers).map(worker => {\n      if (worker.threadId !== -1) {\n        return worker.terminate();\n      }\n      return Promise.resolve();\n    });\n    \n    await Promise.allSettled(promises);\n    this.workers = {};\n  }\n}\n\nexport default WorkerQueue;","import WorkerQueue from './WorkerQueue';\nimport { Lane } from '../types';\nimport path from 'node:path';\n\nconst sizeInMB = (size: number): number => {\n  return size / (1024 * 1024);\n}\n\nconst getSize = (data: any): number => {\n  return sizeInMB(typeof data === 'string' ? Buffer.byteLength(data, 'utf8') : Buffer.byteLength(JSON.stringify(data), 'utf8'));\n}\n\n/**\n * Lanes are used to determine which worker queue to use based on the size of the data.\n * \n * The first lane is for smaller files (<0.1MB), the second lane is for larger files (>=0.1MB).\n * This helps with parsing performance.\n */\nconst LANES: Lane[] = [{\n  maxSize: 0.005\n},{\n  maxSize: 0.1\n},{\n  maxSize: 1\n},{\n  maxSize: 10\n},{\n  maxSize: 100\n}];\n\ninterface WorkerQueueWithSize {\n  maxSize: number;\n  workerQueue: WorkerQueue;\n\n}\n\nclass BruParserWorker {\n  private workerQueues: WorkerQueueWithSize[];\n\n  constructor() {\n    this.workerQueues = LANES?.map(lane => ({\n      maxSize: lane?.maxSize,\n      workerQueue: new WorkerQueue()\n    }));\n  }\n\n  private getWorkerQueue(size: number): WorkerQueue {\n    // Find the first queue that can handle the given size\n    // or fallback to the last queue for largest files\n    const queueForSize = this.workerQueues.find((queue) => \n      queue.maxSize >= size\n    );\n\n    return queueForSize?.workerQueue ?? this.workerQueues[this.workerQueues.length - 1].workerQueue;\n  }\n\n  private async enqueueTask({ data, taskType }: { data: any; taskType: 'parse' | 'stringify' }): Promise<any> {\n    const size = getSize(data);\n    const workerQueue = this.getWorkerQueue(size);\n    const workerScriptPath = path.join(__dirname, './workers/worker-script.js');\n    \n    return workerQueue.enqueue({\n      data,\n      priority: size,\n      scriptPath: workerScriptPath,\n      taskType,\n    });\n  }\n\n  async parseRequest(data: any): Promise<any> {\n    return this.enqueueTask({ data, taskType: 'parse' });\n  }\n\n  async stringifyRequest(data: any): Promise<any> {\n    return this.enqueueTask({ data, taskType: 'stringify' });\n  }\n\n  async cleanup(): Promise<void> {\n    const cleanupPromises = this.workerQueues.map(({ workerQueue }) => \n      workerQueue.cleanup()\n    );\n    await Promise.allSettled(cleanupPromises);\n  }\n}\n\nexport default BruParserWorker; ","import {\n  bruRequestToJson,\n  jsonRequestToBru,\n  bruCollectionToJson,\n  jsonCollectionToBru,\n  bruEnvironmentToJson,\n  jsonEnvironmentToBru\n} from './formats/bru';\nimport { dotenvToJson } from '@usebruno/lang';\nimport BruParserWorker from './workers';\nimport {\n  ParseOptions,\n  StringifyOptions,\n  ParsedRequest,\n  ParsedCollection,\n  ParsedEnvironment\n} from './types';\nimport { bruRequestParseAndRedactBodyData } from './formats/bru/utils/request-parse-and-redact-body-data';\n\nexport const parseRequest = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruRequestToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseRequestAndRedactBody = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruRequestParseAndRedactBodyData(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyRequest = (requestObj: ParsedRequest, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonRequestToBru(requestObj);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nlet globalWorkerInstance: BruParserWorker | null = null;\n\nconst getWorkerInstance = (): BruParserWorker => {\n  if (!globalWorkerInstance) {\n    globalWorkerInstance = new BruParserWorker();\n  }\n  return globalWorkerInstance;\n};\n\nexport const parseRequestViaWorker = async (content: string): Promise<any> => {\n  const fileParserWorker = getWorkerInstance();\n  return await fileParserWorker.parseRequest(content);\n};\n\nexport const stringifyRequestViaWorker = async (requestObj: any): Promise<string> => {\n  const fileParserWorker = getWorkerInstance();\n  return await fileParserWorker.stringifyRequest(requestObj);\n};\n\nexport const parseCollection = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruCollectionToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyCollection = (collectionObj: ParsedCollection, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonCollectionToBru(collectionObj, false);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseFolder = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruCollectionToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyFolder = (folderObj: any, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonCollectionToBru(folderObj, true);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseEnvironment = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruEnvironmentToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyEnvironment = (envObj: ParsedEnvironment, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonEnvironmentToBru(envObj);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\n\nexport const parseDotEnv = (content: string): Record<string, string> => {\n  return dotenvToJson(content);\n};\n\nexport { BruParserWorker };\nexport * from './types';","/**\n * Parses a .bru file and extracts body content while redacting it from the main content\n * @param {string} bruFileContent - The raw content of the .bru file\n * @returns {Object} Object containing redacted file content and extracted body data\n */\nexport const bruRequestParseAndRedactBodyData = (bruFileContent: string) => {\n  try {\n    // Define the patterns that indicate the start of different body types\n    const bodyTypePatterns = [\n      \"body:json {\",\n      \"body:text {\",\n      \"body:xml {\",\n      \"body:sparql {\",\n      \"body:graphql {\"\n    ];\n\n    // Normalize line endings to LF\n    bruFileContent = (bruFileContent || '').replace(/\\r\\n/g, '\\n');\n\n    const EOL = `\\n`;\n\n    /**\n     * Removes the leading 2-space indentation from each line of a string\n     * @param {string} indentedString - The string with leading spaces to remove\n     * @returns {string} The string with indentation removed\n     */\n    const removeLeadingIndentation = (indentedString: string) => {\n      if (!indentedString || !indentedString.length) {\n        return indentedString || '';\n      }\n\n      return indentedString\n        .split(EOL)\n        .map((line) => line.replace(/^  /, ''))\n        .join(EOL);\n    };\n\n    // Split the file content into blocks\n    let fileContentBlocks = bruFileContent.split(`${EOL}}${EOL}`);\n    fileContentBlocks = fileContentBlocks.filter(Boolean).map(_ => _.trim());\n\n    // Extract body blocks and their content\n    const extractedBodyBlocks = fileContentBlocks\n      .filter(block => bodyTypePatterns.some(pattern => block.startsWith(pattern)))\n      .reduce((bodyContentMap: Record<string, string>, bodyBlock) => {\n        // Extract the body type (json, text, xml, etc.) from the first line\n        const firstLine = bodyBlock.split(EOL)[0];\n        const bodyType = firstLine.split(`body:`)[1].split(/\\s/)[0];\n        \n        // Extract the body content (everything between the opening and closing braces)\n        const bodyContentLines = bodyBlock.split(EOL).slice(1);\n        const rawBodyContent = bodyContentLines.join(EOL);\n        \n        // Remove indentation from the body content\n        const cleanBodyContent = removeLeadingIndentation(rawBodyContent);\n        \n        bodyContentMap[bodyType] = cleanBodyContent;\n        return bodyContentMap;\n      }, {});\n\n    // Filter out body blocks to get the remaining file content\n    const fileContentWithoutBodyBlocks = fileContentBlocks.filter(block => \n      !bodyTypePatterns.some(pattern => block.startsWith(pattern))\n    );\n\n    return {\n      bruFileStringWithRedactedBody: fileContentWithoutBodyBlocks.join(`${EOL}}${EOL}${EOL}`).concat(`${EOL}}${EOL}`),\n      extractedBodyContent: extractedBodyBlocks\n    };\n  } catch (error) {\n    console.error('Error parsing and redacting body data:', error);\n    return {\n      bruFileStringWithRedactedBody: bruFileContent,\n      extractedBodyContent: {}\n    };\n  }\n};"],"names":["PARAMETER_MAPPINGS","type","sendIn","source","mapParametersFromSource","sourceParams","length","map","param","collectParametersForType","json","grantType","shouldIncludeParameterType","relevantMappings","filter","mapping","allParams","mappedParams","push","getOauth2AdditionalParameters","auth","oauth2","additionalParameters","parameterTypes","params","error","console","bruCollectionToJson","data","parsed","_collectionBruToJson","collectionBruToJson","transformedJson","request","headers","_","get","script","vars","tests","settings","docs","meta","name","undefined","seq","sequence","isNaN","Number","hasOauth2GrantType","Object","keys","Promise","reject","jsonCollectionToBru","isFolder","collectionBruJson","req","res","_jsonToCollectionBru","WorkerQueue","constructor","this","queue","isProcessing","workers","getWorkerForScriptPath","scriptPath","worker","threadId","Worker","enqueue","task","priority","taskType","resolve","sort","taskX","taskY","processQueue","shift","result","runWorker","async","messageHandler","off","errorHandler","exitHandler","Error","code","on","postMessage","cleanup","promises","values","terminate","allSettled","LANES","maxSize","BruParserWorker","workerQueues","lane","workerQueue","getWorkerQueue","size","queueForSize","find","enqueueTask","Buffer","byteLength","JSON","stringify","getSize","workerScriptPath","path","join","__dirname","parseRequest","stringifyRequest","cleanupPromises","globalWorkerInstance","getWorkerInstance","content","options","format","dotenvToJson","bru","bruToEnvJsonV2","variables","each","v","bruEnvironmentToJson","bruToJsonV2","requestType","tags","method","String","toUpperCase","url","body","assertions","selectedMethodType","methodType","protoPath","mode","grpc","bruRequestToJson","bruFileContent","bodyTypePatterns","replace","EOL","removeLeadingIndentation","indentedString","split","line","fileContentBlocks","Boolean","trim","extractedBodyBlocks","block","some","pattern","startsWith","reduce","bodyContentMap","bodyBlock","bodyType","rawBodyContent","slice","cleanBodyContent","bruFileStringWithRedactedBody","concat","extractedBodyContent","bruRequestParseAndRedactBodyData","fileParserWorker","collectionObj","envObj","envJsonToBruV2","jsonEnvironmentToBru","folderObj","requestObj","bruJson","http","toLowerCase","metadata","jsonToBruV2","jsonRequestToBru"],"mappings":"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"}