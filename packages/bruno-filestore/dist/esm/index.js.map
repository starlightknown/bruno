{"version":3,"file":"index.js","sources":["../../src/formats/bru/utils/oauth2-additional-params.ts","../../src/formats/bru/index.ts","../../src/workers/WorkerQueue/index.ts","../../src/workers/index.ts","../../src/formats/bru/utils/request-parse-and-redact-body-data.ts","../../src/index.ts"],"sourcesContent":["type T_Oauth2ParameterType = 'authorization' | 'token' | 'refresh';\ntype T_Oauth2ParameterSendInType = 'headers' | 'queryparams' | 'body';\n\nexport interface T_OAuth2AdditionalParam {\n  name: string;\n  value: string;\n  enabled: boolean;\n  sendIn: T_Oauth2ParameterSendInType\n}\n\nexport interface T_OAuth2AdditionalParameters {\n  authorization?: T_OAuth2AdditionalParam[];\n  token?: T_OAuth2AdditionalParam[];\n  refresh?: T_OAuth2AdditionalParam[];\n}\n\nexport interface T_Oauth2Auth {\n  grantType: string;\n  additionalParameters?: T_OAuth2AdditionalParameters;\n}\n\nexport interface T_BruJson {\n  auth: {\n    oauth2: T_Oauth2Auth;\n  };\n  oauth2_additional_parameters_auth_req_headers?: any[];\n  oauth2_additional_parameters_auth_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_headers?: any[];\n  oauth2_additional_parameters_access_token_req_queryparams?: any[];\n  oauth2_additional_parameters_access_token_req_bodyvalues?: any[];\n  oauth2_additional_parameters_refresh_token_req_headers?: any[];\n  oauth2_additional_parameters_refresh_token_req_queryparams?: any[];\n  oauth2_additional_parameters_refresh_token_req_bodyvalues?: any[];\n}\n\ninterface T_Oauth2ParameterMapping {\n  type: T_Oauth2ParameterType;\n  sendIn: T_Oauth2ParameterSendInType;\n  source: keyof T_BruJson;\n}\n\nconst PARAMETER_MAPPINGS: T_Oauth2ParameterMapping[] = [\n  // Authorization parameters (only for authorization_code grant type)\n  { type: 'authorization', sendIn: 'headers', source: 'oauth2_additional_parameters_auth_req_headers' },\n  { type: 'authorization', sendIn: 'queryparams', source: 'oauth2_additional_parameters_auth_req_queryparams' },\n  \n  // Token parameters (for all grant types)\n  { type: 'token', sendIn: 'headers', source: 'oauth2_additional_parameters_access_token_req_headers' },\n  { type: 'token', sendIn: 'queryparams', source: 'oauth2_additional_parameters_access_token_req_queryparams' },\n  { type: 'token', sendIn: 'body', source: 'oauth2_additional_parameters_access_token_req_bodyvalues' },\n  \n  // Refresh parameters (for grant types that support refresh)\n  { type: 'refresh', sendIn: 'headers', source: 'oauth2_additional_parameters_refresh_token_req_headers' },\n  { type: 'refresh', sendIn: 'queryparams', source: 'oauth2_additional_parameters_refresh_token_req_queryparams' },\n  { type: 'refresh', sendIn: 'body', source: 'oauth2_additional_parameters_refresh_token_req_bodyvalues' },\n];\n\n/**\n * Maps source parameters to T_OAuth2AdditionalParam format\n */\nconst mapParametersFromSource = (sourceParams: any[], sendIn: T_Oauth2ParameterSendInType): T_OAuth2AdditionalParam[] => {\n  if (!sourceParams?.length) {\n    return [];\n  }\n  \n  return sourceParams.map(param => ({\n    ...param,\n    sendIn\n  }));\n};\n\n/**\n * Checks if a parameter type should be included based on grant type\n */\nconst shouldIncludeParameterType = (type: T_Oauth2ParameterType, grantType: string): boolean => {\n  // Authorization parameters are only valid for authorization_code grant type\n  if (type === 'authorization') {\n    return grantType === 'authorization_code' || grantType === 'implicit';\n  }\n\n  if (type === 'token' || type === 'refresh') {\n    return grantType !== 'implicit';\n  }\n  \n  // Token and refresh parameters are valid for all grant types\n  return true;\n};\n\n/**\n * Collects all parameters for a specific type (authorization, token, or refresh)\n */\nconst collectParametersForType = (\n  json: T_BruJson, \n  type: T_Oauth2ParameterType, \n  grantType: string\n): T_OAuth2AdditionalParam[] => {\n  if (!shouldIncludeParameterType(type, grantType)) {\n    return [];\n  }\n\n  const relevantMappings = PARAMETER_MAPPINGS.filter(mapping => mapping.type === type);\n  const allParams: T_OAuth2AdditionalParam[] = [];\n\n  for (const mapping of relevantMappings) {\n    const sourceParams = json[mapping.source] as any[];\n    const mappedParams = mapParametersFromSource(sourceParams, mapping.sendIn);\n    allParams.push(...mappedParams);\n  }\n\n  return allParams;\n};\n\n/**\n * This function extracts OAuth2 additional parameters from various sources in the bru json data and organizes\n * them into a structured format based on their usage context (authorization, token, refresh).\n * \n * @param json - json object containing OAuth2 configuration and additional parameters\n * @returns OAuth2 additional parameters\n */\nexport const getOauth2AdditionalParameters = (json: T_BruJson): T_OAuth2AdditionalParameters  => {\n  const grantType = json.auth.oauth2.grantType;\n  const additionalParameters: T_OAuth2AdditionalParameters = {};\n\n  try {\n    // Collect parameters for each type\n    const parameterTypes: T_Oauth2ParameterType[] = ['authorization', 'token', 'refresh'];\n    \n    for (const type of parameterTypes) {\n      const params = collectParametersForType(json, type, grantType);\n      if (params.length > 0) {\n        additionalParameters[type] = params;\n      }\n    }\n  }\n  catch(error) {\n    console.error(error);\n    console.error(\"Error while getting the oauth2 additional parameters!\");\n  }\n  \n  return additionalParameters;\n};","import * as _ from 'lodash';\nimport {\n  bruToJsonV2,\n  jsonToBruV2,\n  bruToEnvJsonV2,\n  envJsonToBruV2,\n  collectionBruToJson as _collectionBruToJson,\n  jsonToCollectionBru as _jsonToCollectionBru\n} from '@usebruno/lang';\nimport { getOauth2AdditionalParameters } from './utils/oauth2-additional-params';\n\nexport const bruRequestToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : bruToJsonV2(data);\n\n    let requestType = _.get(json, 'meta.type');\n    switch (requestType) {\n      case 'http':\n        requestType = 'http-request';\n        break;\n      case 'graphql':\n        requestType = 'graphql-request';\n        break;\n      case 'grpc':\n        requestType = 'grpc-request';\n        break;\n      default:\n        requestType = 'http-request';\n    }\n\n    const sequence = _.get(json, 'meta.seq');\n    const transformedJson = {\n      type: requestType,\n      name: _.get(json, 'meta.name'),\n      seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n      settings: _.get(json, 'settings', {}),\n      tags: _.get(json, 'meta.tags', []),\n      request: {\n        // Preserving special characters in custom methods. Using _.upperCase strips special characters.\n        method:\n          requestType === 'grpc-request' ? _.get(json, 'grpc.method', '') : String(_.get(json, 'http.method') ?? '').toUpperCase(),\n        url: _.get(json, requestType === 'grpc-request' ? 'grpc.url' : 'http.url'),\n        headers: requestType === 'grpc-request' ? _.get(json, 'metadata', []) : _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        body: _.get(json, 'body', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        assertions: _.get(json, 'assertions', []),\n        tests: _.get(json, 'tests', ''),\n        docs: _.get(json, 'docs', '')\n      }\n    };\n\n    // Add request type specific fields\n    if (requestType === 'grpc-request') {\n      const selectedMethodType = _.get(json, 'grpc.methodType');\n      selectedMethodType && ((transformedJson.request as any).methodType = selectedMethodType);\n      const protoPath = _.get(json, 'grpc.protoPath');\n      protoPath && ((transformedJson.request as any).protoPath = protoPath);\n      transformedJson.request.auth.mode = _.get(json, 'grpc.auth', 'none');\n      transformedJson.request.body = _.get(json, 'body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    } else {\n      // For HTTP and GraphQL\n      (transformedJson.request as any).params = _.get(json, 'params', []);\n      transformedJson.request.auth.mode = _.get(json, 'http.auth', 'none');\n      transformedJson.request.body.mode = _.get(json, 'http.body', 'none');\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters || {}).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const jsonRequestToBru = (json: any): string => {\n  try {\n    let type = _.get(json, 'type');\n    switch (type) {\n      case 'http-request':\n        type = 'http';\n        break;\n      case 'graphql-request':\n        type = 'graphql';\n        break;\n      case 'grpc-request':\n        type = 'grpc';\n        break;\n      default:\n        type = 'http';\n    }\n\n    const sequence = _.get(json, 'seq');\n\n    // Start with the common meta section\n    const bruJson = {\n      meta: {\n        name: _.get(json, 'name'),\n        type: type,\n        seq: !_.isNaN(sequence) ? Number(sequence) : 1,\n        tags: _.get(json, 'tags', [])\n      }\n    } as any;\n\n    // For HTTP and GraphQL requests, maintain the current structure\n    if (type === 'http' || type === 'graphql') {\n      bruJson.http = {\n        // Preserve special characters in custom request methods. Avoid _.lowerCase which strips symbols.\n        method: String(_.get(json, 'request.method') ?? '').toLowerCase(),\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'none')\n      };\n      bruJson.params = _.get(json, 'request.params', []);\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'json',\n        json: '{}'\n      });\n    } // For gRPC, add gRPC-specific structure but maintain field names\n    else if (type === 'grpc') {\n      bruJson.grpc = {\n        url: _.get(json, 'request.url'),\n        auth: _.get(json, 'request.auth.mode', 'none'),\n        body: _.get(json, 'request.body.mode', 'grpc')\n      };\n      // Only add method if it exists\n      const method = _.get(json, 'request.method');\n      const methodType = _.get(json, 'request.methodType');\n      const protoPath = _.get(json, 'request.protoPath');\n      if (method) bruJson.grpc.method = method;\n      if (methodType) bruJson.grpc.methodType = methodType;\n      if (protoPath) bruJson.grpc.protoPath = protoPath;\n      bruJson.body = _.get(json, 'request.body', {\n        mode: 'grpc',\n        grpc: _.get(json, 'request.body.grpc', [\n          {\n            name: 'message 1',\n            content: '{}'\n          }\n        ])\n      });\n    }\n\n    // Common fields for all request types\n    if (type === 'grpc') {\n      bruJson.metadata = _.get(json, 'request.headers', []); // Use metadata for gRPC\n    } else {\n      bruJson.headers = _.get(json, 'request.headers', []); // Use headers for HTTP/GraphQL\n    }\n    bruJson.auth = _.get(json, 'request.auth', {});\n    bruJson.script = _.get(json, 'request.script', {});\n    bruJson.vars = {\n      req: _.get(json, 'request.vars.req', []),\n      res: _.get(json, 'request.vars.res', [])\n    };\n    // should we add assertions and tests for grpc requests?\n    bruJson.assertions = _.get(json, 'request.assertions', []);\n    bruJson.tests = _.get(json, 'request.tests', '');\n    bruJson.settings = _.get(json, 'settings', {});\n    bruJson.docs = _.get(json, 'request.docs', '');\n\n    const bru = jsonToBruV2(bruJson);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruCollectionToJson = (data: string | any, parsed: boolean = false): any => {\n  try {\n    const json = parsed ? data : _collectionBruToJson(data);\n\n    const transformedJson: any = {\n      request: {\n        headers: _.get(json, 'headers', []),\n        auth: _.get(json, 'auth', {}),\n        script: _.get(json, 'script', {}),\n        vars: _.get(json, 'vars', {}),\n        tests: _.get(json, 'tests', '')\n      },\n      settings: _.get(json, 'settings', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json.meta) {\n      transformedJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        transformedJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    // add oauth2 additional parameters if they exist\n    const hasOauth2GrantType = json?.auth?.oauth2?.grantType;\n    if (hasOauth2GrantType) {\n      const additionalParameters = getOauth2AdditionalParameters(json);\n      const hasAdditionalParameters = Object.keys(additionalParameters).length > 0;\n      if (hasAdditionalParameters) {\n        transformedJson.request.auth.oauth2.additionalParameters = additionalParameters;\n      }\n    }\n\n    return transformedJson;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonCollectionToBru = (json: any, isFolder?: boolean): string => {\n  try {\n    const collectionBruJson: any = {\n      headers: _.get(json, 'request.headers', []),\n      script: {\n        req: _.get(json, 'request.script.req', ''),\n        res: _.get(json, 'request.script.res', '')\n      },\n      vars: {\n        req: _.get(json, 'request.vars.req', []),\n        res: _.get(json, 'request.vars.res', [])\n      },\n      tests: _.get(json, 'request.tests', ''),\n      auth: _.get(json, 'request.auth', {}),\n      docs: _.get(json, 'docs', '')\n    };\n\n    // add meta if it exists\n    // this is only for folder bru file\n    if (json?.meta) {\n      collectionBruJson.meta = {\n        name: json.meta.name\n      };\n\n      // Include seq if it exists\n      if (json.meta.seq !== undefined) {\n        const sequence = json.meta.seq;\n        collectionBruJson.meta.seq = !isNaN(sequence) ? Number(sequence) : 1;\n      }\n    }\n\n    if (!isFolder) {\n      collectionBruJson.auth = _.get(json, 'request.auth', {});\n    }\n\n    return _jsonToCollectionBru(collectionBruJson);\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const bruEnvironmentToJson = (bru: string): any => {\n  try {\n    const json = bruToEnvJsonV2(bru);\n\n    // the app env format requires each variable to have a type\n    // this need to be evaluated and safely removed\n    // i don't see it being used in schema validation\n    if (json && json.variables && json.variables.length) {\n      _.each(json.variables, (v: any) => (v.type = 'text'));\n    }\n\n    return json;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nexport const jsonEnvironmentToBru = (json: any): string => {\n  try {\n    const bru = envJsonToBruV2(json);\n    return bru;\n  } catch (error) {\n    throw error;\n  }\n};\n","import { Worker } from 'node:worker_threads';\n\ninterface QueuedTask {\n  priority: number;\n  scriptPath: string;\n  data: any;\n  taskType: 'parse' | 'stringify';\n  resolve?: (value: any) => void;\n  reject?: (reason?: any) => void;\n}\n\nclass WorkerQueue {\n  private queue: QueuedTask[];\n  private isProcessing: boolean;\n  private workers: Record<string, Worker>;\n\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n    this.workers = {};\n  }\n\n  async getWorkerForScriptPath(scriptPath: string) {\n    if (!this.workers) this.workers = {}; \n    let worker = this.workers[scriptPath];\n    if (!worker || worker.threadId === -1) {\n      this.workers[scriptPath] = worker = new Worker(scriptPath);\n    }\n    return worker;\n  }\n  \n  async enqueue(task: QueuedTask) {\n    const { priority, scriptPath, data, taskType } = task;\n\n    return new Promise((resolve, reject) => {\n      this.queue.push({ priority, scriptPath, data, taskType, resolve, reject });\n      this.queue?.sort((taskX, taskY) => taskX?.priority - taskY?.priority);\n      this.processQueue();\n    });\n  }\n\n  async processQueue() {\n    if (this.isProcessing || this.queue.length === 0){\n      return;\n    } \n\n    this.isProcessing = true;\n    const { scriptPath, data, taskType, resolve, reject } = this.queue.shift() as QueuedTask;\n\n    try {\n      const result = await this.runWorker({ scriptPath, data, taskType });\n      resolve?.(result);\n    } catch (error) {\n      reject?.(error);\n    } finally {\n      this.isProcessing = false;\n      this.processQueue();\n    }\n  }\n\n  async runWorker({ scriptPath, data, taskType }: { scriptPath: string; data: any; taskType: 'parse' | 'stringify' }) {\n    return new Promise(async (resolve, reject) => {\n      let worker = await this.getWorkerForScriptPath(scriptPath);\n      \n      const messageHandler = (data: any) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        \n        if (data?.error) {\n          reject(new Error(data?.error));\n        } else {\n          resolve(data);\n        }\n      };\n\n      const errorHandler = (error: Error) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        reject(error);\n      };\n\n      const exitHandler = (code: number) => {\n        worker.off('message', messageHandler);\n        worker.off('error', errorHandler);\n        worker.off('exit', exitHandler);\n        // Remove dead worker from cache\n        delete this.workers[scriptPath];\n        reject(new Error(`Worker stopped with exit code ${code}`));\n      };\n      \n      worker.on('message', messageHandler);\n      worker.on('error', errorHandler);\n      worker.on('exit', exitHandler);\n\n      worker.postMessage({ taskType, data });\n    });\n  }\n\n  async cleanup() {\n    const promises = Object.values(this.workers).map(worker => {\n      if (worker.threadId !== -1) {\n        return worker.terminate();\n      }\n      return Promise.resolve();\n    });\n    \n    await Promise.allSettled(promises);\n    this.workers = {};\n  }\n}\n\nexport default WorkerQueue;","import WorkerQueue from './WorkerQueue';\nimport { Lane } from '../types';\nimport path from 'node:path';\n\nconst sizeInMB = (size: number): number => {\n  return size / (1024 * 1024);\n}\n\nconst getSize = (data: any): number => {\n  return sizeInMB(typeof data === 'string' ? Buffer.byteLength(data, 'utf8') : Buffer.byteLength(JSON.stringify(data), 'utf8'));\n}\n\n/**\n * Lanes are used to determine which worker queue to use based on the size of the data.\n * \n * The first lane is for smaller files (<0.1MB), the second lane is for larger files (>=0.1MB).\n * This helps with parsing performance.\n */\nconst LANES: Lane[] = [{\n  maxSize: 0.005\n},{\n  maxSize: 0.1\n},{\n  maxSize: 1\n},{\n  maxSize: 10\n},{\n  maxSize: 100\n}];\n\ninterface WorkerQueueWithSize {\n  maxSize: number;\n  workerQueue: WorkerQueue;\n\n}\n\nclass BruParserWorker {\n  private workerQueues: WorkerQueueWithSize[];\n\n  constructor() {\n    this.workerQueues = LANES?.map(lane => ({\n      maxSize: lane?.maxSize,\n      workerQueue: new WorkerQueue()\n    }));\n  }\n\n  private getWorkerQueue(size: number): WorkerQueue {\n    // Find the first queue that can handle the given size\n    // or fallback to the last queue for largest files\n    const queueForSize = this.workerQueues.find((queue) => \n      queue.maxSize >= size\n    );\n\n    return queueForSize?.workerQueue ?? this.workerQueues[this.workerQueues.length - 1].workerQueue;\n  }\n\n  private async enqueueTask({ data, taskType }: { data: any; taskType: 'parse' | 'stringify' }): Promise<any> {\n    const size = getSize(data);\n    const workerQueue = this.getWorkerQueue(size);\n    const workerScriptPath = path.join(__dirname, './workers/worker-script.js');\n    \n    return workerQueue.enqueue({\n      data,\n      priority: size,\n      scriptPath: workerScriptPath,\n      taskType,\n    });\n  }\n\n  async parseRequest(data: any): Promise<any> {\n    return this.enqueueTask({ data, taskType: 'parse' });\n  }\n\n  async stringifyRequest(data: any): Promise<any> {\n    return this.enqueueTask({ data, taskType: 'stringify' });\n  }\n\n  async cleanup(): Promise<void> {\n    const cleanupPromises = this.workerQueues.map(({ workerQueue }) => \n      workerQueue.cleanup()\n    );\n    await Promise.allSettled(cleanupPromises);\n  }\n}\n\nexport default BruParserWorker; ","/**\n * Parses a .bru file and extracts body content while redacting it from the main content\n * @param {string} bruFileContent - The raw content of the .bru file\n * @returns {Object} Object containing redacted file content and extracted body data\n */\nexport const bruRequestParseAndRedactBodyData = (bruFileContent: string) => {\n  try {\n    // Define the patterns that indicate the start of different body types\n    const bodyTypePatterns = [\n      \"body:json {\",\n      \"body:text {\",\n      \"body:xml {\",\n      \"body:sparql {\",\n      \"body:graphql {\"\n    ];\n\n    // Normalize line endings to LF\n    bruFileContent = (bruFileContent || '').replace(/\\r\\n/g, '\\n');\n\n    const EOL = `\\n`;\n\n    /**\n     * Removes the leading 2-space indentation from each line of a string\n     * @param {string} indentedString - The string with leading spaces to remove\n     * @returns {string} The string with indentation removed\n     */\n    const removeLeadingIndentation = (indentedString: string) => {\n      if (!indentedString || !indentedString.length) {\n        return indentedString || '';\n      }\n\n      return indentedString\n        .split(EOL)\n        .map((line) => line.replace(/^  /, ''))\n        .join(EOL);\n    };\n\n    // Split the file content into blocks\n    let fileContentBlocks = bruFileContent.split(`${EOL}}${EOL}`);\n    fileContentBlocks = fileContentBlocks.filter(Boolean).map(_ => _.trim());\n\n    // Extract body blocks and their content\n    const extractedBodyBlocks = fileContentBlocks\n      .filter(block => bodyTypePatterns.some(pattern => block.startsWith(pattern)))\n      .reduce((bodyContentMap: Record<string, string>, bodyBlock) => {\n        // Extract the body type (json, text, xml, etc.) from the first line\n        const firstLine = bodyBlock.split(EOL)[0];\n        const bodyType = firstLine.split(`body:`)[1].split(/\\s/)[0];\n        \n        // Extract the body content (everything between the opening and closing braces)\n        const bodyContentLines = bodyBlock.split(EOL).slice(1);\n        const rawBodyContent = bodyContentLines.join(EOL);\n        \n        // Remove indentation from the body content\n        const cleanBodyContent = removeLeadingIndentation(rawBodyContent);\n        \n        bodyContentMap[bodyType] = cleanBodyContent;\n        return bodyContentMap;\n      }, {});\n\n    // Filter out body blocks to get the remaining file content\n    const fileContentWithoutBodyBlocks = fileContentBlocks.filter(block => \n      !bodyTypePatterns.some(pattern => block.startsWith(pattern))\n    );\n\n    return {\n      bruFileStringWithRedactedBody: fileContentWithoutBodyBlocks.join(`${EOL}}${EOL}${EOL}`).concat(`${EOL}}${EOL}`),\n      extractedBodyContent: extractedBodyBlocks\n    };\n  } catch (error) {\n    console.error('Error parsing and redacting body data:', error);\n    return {\n      bruFileStringWithRedactedBody: bruFileContent,\n      extractedBodyContent: {}\n    };\n  }\n};","import {\n  bruRequestToJson,\n  jsonRequestToBru,\n  bruCollectionToJson,\n  jsonCollectionToBru,\n  bruEnvironmentToJson,\n  jsonEnvironmentToBru\n} from './formats/bru';\nimport { dotenvToJson } from '@usebruno/lang';\nimport BruParserWorker from './workers';\nimport {\n  ParseOptions,\n  StringifyOptions,\n  ParsedRequest,\n  ParsedCollection,\n  ParsedEnvironment\n} from './types';\nimport { bruRequestParseAndRedactBodyData } from './formats/bru/utils/request-parse-and-redact-body-data';\n\nexport const parseRequest = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruRequestToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseRequestAndRedactBody = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruRequestParseAndRedactBodyData(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyRequest = (requestObj: ParsedRequest, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonRequestToBru(requestObj);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nlet globalWorkerInstance: BruParserWorker | null = null;\n\nconst getWorkerInstance = (): BruParserWorker => {\n  if (!globalWorkerInstance) {\n    globalWorkerInstance = new BruParserWorker();\n  }\n  return globalWorkerInstance;\n};\n\nexport const parseRequestViaWorker = async (content: string): Promise<any> => {\n  const fileParserWorker = getWorkerInstance();\n  return await fileParserWorker.parseRequest(content);\n};\n\nexport const stringifyRequestViaWorker = async (requestObj: any): Promise<string> => {\n  const fileParserWorker = getWorkerInstance();\n  return await fileParserWorker.stringifyRequest(requestObj);\n};\n\nexport const parseCollection = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruCollectionToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyCollection = (collectionObj: ParsedCollection, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonCollectionToBru(collectionObj, false);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseFolder = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruCollectionToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyFolder = (folderObj: any, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonCollectionToBru(folderObj, true);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const parseEnvironment = (content: string, options: ParseOptions = { format: 'bru' }): any => {\n  if (options.format === 'bru') {\n    return bruEnvironmentToJson(content);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\nexport const stringifyEnvironment = (envObj: ParsedEnvironment, options: StringifyOptions = { format: 'bru' }): string => {\n  if (options.format === 'bru') {\n    return jsonEnvironmentToBru(envObj);\n  }\n  throw new Error(`Unsupported format: ${options.format}`);\n};\n\n\nexport const parseDotEnv = (content: string): Record<string, string> => {\n  return dotenvToJson(content);\n};\n\nexport { BruParserWorker };\nexport * from './types';"],"names":["PARAMETER_MAPPINGS","type","sendIn","source","mapParametersFromSource","sourceParams","length","map","param","collectParametersForType","json","grantType","shouldIncludeParameterType","relevantMappings","filter","mapping","allParams","mappedParams","push","getOauth2AdditionalParameters","auth","oauth2","additionalParameters","parameterTypes","params","error","console","bruCollectionToJson","data","parsed","_collectionBruToJson","transformedJson","request","headers","_","get","script","vars","tests","settings","docs","meta","name","undefined","seq","sequence","isNaN","Number","hasOauth2GrantType","Object","keys","Promise","reject","jsonCollectionToBru","isFolder","collectionBruJson","req","res","_jsonToCollectionBru","WorkerQueue","constructor","this","queue","isProcessing","workers","getWorkerForScriptPath","scriptPath","worker","threadId","Worker","enqueue","task","priority","taskType","resolve","sort","taskX","taskY","processQueue","shift","result","runWorker","async","messageHandler","off","errorHandler","exitHandler","Error","code","on","postMessage","cleanup","promises","values","terminate","allSettled","LANES","maxSize","BruParserWorker","workerQueues","lane","workerQueue","getWorkerQueue","size","queueForSize","find","enqueueTask","Buffer","byteLength","JSON","stringify","getSize","workerScriptPath","path","join","__dirname","parseRequest","stringifyRequest","cleanupPromises","content","options","format","bruToJsonV2","requestType","tags","method","String","toUpperCase","url","body","assertions","selectedMethodType","methodType","protoPath","mode","grpc","bruRequestToJson","parseRequestAndRedactBody","bruFileContent","bodyTypePatterns","replace","EOL","removeLeadingIndentation","indentedString","split","line","fileContentBlocks","Boolean","trim","extractedBodyBlocks","block","some","pattern","startsWith","reduce","bodyContentMap","bodyBlock","bodyType","rawBodyContent","slice","cleanBodyContent","bruFileStringWithRedactedBody","concat","extractedBodyContent","bruRequestParseAndRedactBodyData","requestObj","bruJson","http","toLowerCase","metadata","jsonToBruV2","jsonRequestToBru","globalWorkerInstance","getWorkerInstance","parseRequestViaWorker","fileParserWorker","stringifyRequestViaWorker","parseCollection","stringifyCollection","collectionObj","parseFolder","stringifyFolder","folderObj","parseEnvironment","bru","bruToEnvJsonV2","variables","each","v","bruEnvironmentToJson","stringifyEnvironment","envObj","envJsonToBruV2","jsonEnvironmentToBru","parseDotEnv","dotenvToJson"],"mappings":"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"}